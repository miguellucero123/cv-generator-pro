 Fase 3: Integraci√≥n Avanzada - CV Generator Pro
¬°Perfecto! Continuemos con la Fase 3. Vamos a construir el backend completo y las integraciones avanzadas.

üìÅ Estructura del Proyecto Backend
text
cv-generator-backend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ passport.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cloudinary.js
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CV.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Analytics.js
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cv.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ analytics.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ share.js
‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authController.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cvController.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ analyticsController.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ shareController.js
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rateLimiter.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.js
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ linkedinService.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pdfService.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ emailService.js
‚îÇ   ‚îî‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ server.js
1Ô∏è‚É£ Configuraci√≥n Inicial del Backend
package.json
json
{
  "name": "cv-generator-backend",
  "version": "2.0.0",
  "description": "Backend API for CV Generator Pro",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^8.0.0",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "passport-linkedin-oauth2": "^2.0.0",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "express-validator": "^7.0.1",
    "multer": "^1.4.5-lts.1",
    "cloudinary": "^1.41.0",
    "nodemailer": "^6.9.7",
    "puppeteer": "^21.6.0",
    "uuid": "^9.0.1",
    "dotenv": "^16.3.1",
    "morgan": "^1.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "jest": "^29.7.0"
  }
}
.env
env
# Server
PORT=5000
NODE_ENV=development

# Database
MONGODB_URI=mongodb://localhost:27017/cv-generator
# O MongoDB Atlas: mongodb+srv://user:pass@cluster.mongodb.net/cv-generator

# JWT
JWT_SECRET=tu_super_secreto_jwt_muy_largo_y_seguro_123!
JWT_EXPIRE=7d

# Google OAuth
GOOGLE_CLIENT_ID=tu_google_client_id
GOOGLE_CLIENT_SECRET=tu_google_client_secret
GOOGLE_CALLBACK_URL=http://localhost:5000/api/auth/google/callback

# LinkedIn OAuth
LINKEDIN_CLIENT_ID=tu_linkedin_client_id
LINKEDIN_CLIENT_SECRET=tu_linkedin_client_secret
LINKEDIN_CALLBACK_URL=http://localhost:5000/api/auth/linkedin/callback

# Cloudinary (para fotos)
CLOUDINARY_CLOUD_NAME=tu_cloud_name
CLOUDINARY_API_KEY=tu_api_key
CLOUDINARY_API_SECRET=tu_api_secret

# Frontend URL
FRONTEND_URL=http://localhost:3000

# Email (Nodemailer)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=tu_email@gmail.com
SMTP_PASS=tu_app_password
2Ô∏è‚É£ Configuraci√≥n de Base de Datos
src/config/database.js
javascript
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI, {
      // Mongoose 8 usa estas opciones por defecto
    });

    console.log(`‚úÖ MongoDB Connected: ${conn.connection.host}`);

    // Eventos de conexi√≥n
    mongoose.connection.on('error', (err) => {
      console.error('‚ùå MongoDB connection error:', err);
    });

    mongoose.connection.on('disconnected', () => {
      console.warn('‚ö†Ô∏è MongoDB disconnected');
    });

    // Graceful shutdown
    process.on('SIGINT', async () => {
      await mongoose.connection.close();
      console.log('MongoDB connection closed through app termination');
      process.exit(0);
    });

  } catch (error) {
    console.error('‚ùå Error connecting to MongoDB:', error.message);
    process.exit(1);
  }
};

module.exports = connectDB;
3Ô∏è‚É£ Modelos de Base de Datos
src/models/User.js
javascript
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, 'El email es requerido'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^\S+@\S+\.\S+$/, 'Email inv√°lido']
  },
  password: {
    type: String,
    minlength: [6, 'La contrase√±a debe tener al menos 6 caracteres'],
    select: false // No incluir en queries por defecto
  },
  name: {
    type: String,
    required: [true, 'El nombre es requerido'],
    trim: true,
    maxlength: [100, 'Nombre muy largo']
  },
  avatar: {
    type: String,
    default: null
  },
  provider: {
    type: String,
    enum: ['local', 'google', 'linkedin'],
    default: 'local'
  },
  providerId: String,
  
  // Configuraci√≥n del usuario
  settings: {
    language: {
      type: String,
      enum: ['es', 'en', 'pt'],
      default: 'es'
    },
    theme: {
      type: String,
      enum: ['light', 'dark', 'system'],
      default: 'system'
    },
    emailNotifications: {
      type: Boolean,
      default: true
    }
  },

  // Plan del usuario
  plan: {
    type: String,
    enum: ['free', 'pro', 'enterprise'],
    default: 'free'
  },
  planExpires: Date,

  // L√≠mites de uso
  usage: {
    cvsCreated: { type: Number, default: 0 },
    cvsExported: { type: Number, default: 0 },
    lastExport: Date
  },

  // Verificaci√≥n y seguridad
  isVerified: {
    type: Boolean,
    default: false
  },
  verificationToken: String,
  verificationExpires: Date,
  resetPasswordToken: String,
  resetPasswordExpires: Date,
  
  lastLogin: Date,
  loginAttempts: {
    type: Number,
    default: 0
  },
  lockUntil: Date

}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual para CVs del usuario
userSchema.virtual('cvs', {
  ref: 'CV',
  localField: '_id',
  foreignField: 'user'
});

// √çndices
userSchema.index({ email: 1 });
userSchema.index({ provider: 1, providerId: 1 });

// Middleware: Hash password antes de guardar
userSchema.pre('save', async function(next) {
  if (!this.isModified('password') || !this.password) {
    return next();
  }
  
  const salt = await bcrypt.genSalt(12);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// M√©todo: Comparar passwords
userSchema.methods.comparePassword = async function(candidatePassword) {
  if (!this.password) return false;
  return await bcrypt.compare(candidatePassword, this.password);
};

// M√©todo: Generar JWT
userSchema.methods.generateAuthToken = function() {
  return jwt.sign(
    { 
      id: this._id,
      email: this.email,
      plan: this.plan 
    },
    process.env.JWT_SECRET,
    { expiresIn: process.env.JWT_EXPIRE }
  );
};

// M√©todo: Verificar si cuenta est√° bloqueada
userSchema.methods.isLocked = function() {
  return this.lockUntil && this.lockUntil > Date.now();
};

// M√©todo: Incrementar intentos de login
userSchema.methods.incLoginAttempts = async function() {
  // Si tenemos un bloqueo previo que ya expir√≥, reiniciar
  if (this.lockUntil && this.lockUntil < Date.now()) {
    return this.updateOne({
      $set: { loginAttempts: 1 },
      $unset: { lockUntil: 1 }
    });
  }
  
  const updates = { $inc: { loginAttempts: 1 } };
  
  // Bloquear cuenta despu√©s de 5 intentos fallidos
  if (this.loginAttempts + 1 >= 5) {
    updates.$set = { lockUntil: Date.now() + 2 * 60 * 60 * 1000 }; // 2 horas
  }
  
  return this.updateOne(updates);
};

// M√©todo: Obtener l√≠mites seg√∫n plan
userSchema.methods.getPlanLimits = function() {
  const limits = {
    free: { cvs: 3, exports: 10, templates: ['modern', 'classic'] },
    pro: { cvs: 20, exports: 100, templates: 'all' },
    enterprise: { cvs: Infinity, exports: Infinity, templates: 'all' }
  };
  return limits[this.plan];
};

// M√©todo: Puede crear m√°s CVs
userSchema.methods.canCreateCV = function() {
  const limits = this.getPlanLimits();
  return this.usage.cvsCreated < limits.cvs;
};

// Statics: Buscar por credenciales
userSchema.statics.findByCredentials = async function(email, password) {
  const user = await this.findOne({ email }).select('+password');
  
  if (!user) {
    throw new Error('Credenciales inv√°lidas');
  }
  
  if (user.isLocked()) {
    throw new Error('Cuenta bloqueada temporalmente. Intenta m√°s tarde.');
  }
  
  const isMatch = await user.comparePassword(password);
  
  if (!isMatch) {
    await user.incLoginAttempts();
    throw new Error('Credenciales inv√°lidas');
  }
  
  // Resetear intentos en login exitoso
  if (user.loginAttempts > 0) {
    await user.updateOne({
      $set: { loginAttempts: 0, lastLogin: new Date() },
      $unset: { lockUntil: 1 }
    });
  }
  
  return user;
};

module.exports = mongoose.model('User', userSchema);
src/models/CV.js
javascript
const mongoose = require('mongoose');
const { v4: uuidv4 } = require('uuid');

// Sub-esquemas para mejor organizaci√≥n
const contactSchema = new mongoose.Schema({
  email: { type: String, trim: true },
  phone: { type: String, trim: true },
  location: { type: String, trim: true },
  linkedin: { type: String, trim: true },
  github: { type: String, trim: true },
  portfolio: { type: String, trim: true },
  website: { type: String, trim: true }
}, { _id: false });

const experienceSchema = new mongoose.Schema({
  id: { type: String, default: () => uuidv4() },
  company: { type: String, required: true, trim: true },
  position: { type: String, required: true, trim: true },
  location: { type: String, trim: true },
  startDate: { type: String, required: true },
  endDate: { type: String },
  current: { type: Boolean, default: false },
  description: { type: String, trim: true },
  achievements: [{ type: String, trim: true }]
}, { _id: false });

const educationSchema = new mongoose.Schema({
  id: { type: String, default: () => uuidv4() },
  institution: { type: String, required: true, trim: true },
  degree: { type: String, required: true, trim: true },
  field: { type: String, trim: true },
  location: { type: String, trim: true },
  startDate: { type: String, required: true },
  endDate: { type: String },
  current: { type: Boolean, default: false },
  gpa: { type: String, trim: true },
  achievements: [{ type: String, trim: true }]
}, { _id: false });

const skillSchema = new mongoose.Schema({
  id: { type: String, default: () => uuidv4() },
  name: { type: String, required: true, trim: true },
  level: { 
    type: Number, 
    min: 1, 
    max: 5,
    default: 3 
  },
  category: { 
    type: String, 
    enum: ['technical', 'soft', 'language', 'tool', 'other'],
    default: 'technical'
  }
}, { _id: false });

const projectSchema = new mongoose.Schema({
  id: { type: String, default: () => uuidv4() },
  name: { type: String, required: true, trim: true },
  description: { type: String, trim: true },
  technologies: [{ type: String, trim: true }],
  url: { type: String, trim: true },
  github: { type: String, trim: true },
  image: { type: String },
  startDate: { type: String },
  endDate: { type: String }
}, { _id: false });

const certificationSchema = new mongoose.Schema({
  id: { type: String, default: () => uuidv4() },
  name: { type: String, required: true, trim: true },
  issuer: { type: String, required: true, trim: true },
  date: { type: String },
  expires: { type: String },
  credentialId: { type: String, trim: true },
  url: { type: String, trim: true }
}, { _id: false });

const languageSchema = new mongoose.Schema({
  id: { type: String, default: () => uuidv4() },
  name: { type: String, required: true, trim: true },
  level: { 
    type: String,
    enum: ['native', 'fluent', 'advanced', 'intermediate', 'basic'],
    default: 'intermediate'
  }
}, { _id: false });

// Esquema principal del CV
const cvSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  
  // Metadatos del CV
  title: {
    type: String,
    required: [true, 'El t√≠tulo del CV es requerido'],
    trim: true,
    maxlength: [100, 'T√≠tulo muy largo'],
    default: 'Mi CV'
  },
  slug: {
    type: String,
    unique: true,
    sparse: true
  },
  
  // Informaci√≥n personal
  personalInfo: {
    firstName: { type: String, trim: true },
    lastName: { type: String, trim: true },
    title: { type: String, trim: true }, // T√≠tulo profesional
    photo: { type: String }, // URL de Cloudinary
    summary: { type: String, trim: true, maxlength: 2000 },
    contact: contactSchema
  },
  
  // Secciones del CV
  experience: [experienceSchema],
  education: [educationSchema],
  skills: [skillSchema],
  projects: [projectSchema],
  certifications: [certificationSchema],
  languages: [languageSchema],
  
  // Secciones personalizadas
  customSections: [{
    id: { type: String, default: () => uuidv4() },
    title: { type: String, required: true, trim: true },
    content: { type: String, trim: true },
    items: [{
      id: { type: String, default: () => uuidv4() },
      title: { type: String, trim: true },
      subtitle: { type: String, trim: true },
      date: { type: String },
      description: { type: String, trim: true }
    }]
  }],
  
  // Configuraci√≥n de dise√±o
  design: {
    template: {
      type: String,
      enum: ['modern', 'classic', 'creative', 'minimal', 'executive', 'tech'],
      default: 'modern'
    },
    primaryColor: {
      type: String,
      default: '#3B82F6',
      match: [/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, 'Color inv√°lido']
    },
    secondaryColor: {
      type: String,
      default: '#1E40AF'
    },
    fontFamily: {
      type: String,
      enum: ['inter', 'roboto', 'poppins', 'playfair', 'montserrat'],
      default: 'inter'
    },
    fontSize: {
      type: String,
      enum: ['small', 'medium', 'large'],
      default: 'medium'
    },
    spacing: {
      type: String,
      enum: ['compact', 'normal', 'relaxed'],
      default: 'normal'
    },
    showPhoto: { type: Boolean, default: true },
    showSkillLevels: { type: Boolean, default: true }
  },
  
  // Orden de secciones
  sectionOrder: {
    type: [String],
    default: ['summary', 'experience', 'education', 'skills', 'projects', 'certifications', 'languages']
  },
  
  // Visibilidad de secciones
  visibleSections: {
    summary: { type: Boolean, default: true },
    experience: { type: Boolean, default: true },
    education: { type: Boolean, default: true },
    skills: { type: Boolean, default: true },
    projects: { type: Boolean, default: true },
    certifications: { type: Boolean, default: true },
    languages: { type: Boolean, default: true }
  },
  
  // Compartir
  sharing: {
    isPublic: { type: Boolean, default: false },
    publicUrl: { type: String, unique: true, sparse: true },
    password: { type: String, select: false },
    expiresAt: Date,
    allowDownload: { type: Boolean, default: true }
  },
  
  // Estado
  status: {
    type: String,
    enum: ['draft', 'published', 'archived'],
    default: 'draft'
  },
  
  // Analytics
  analytics: {
    views: { type: Number, default: 0 },
    downloads: { type: Number, default: 0 },
    lastViewed: Date,
    lastDownloaded: Date
  },
  
  // Versionado
  version: { type: Number, default: 1 },
  lastModifiedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  
  // Importaci√≥n
  importedFrom: {
    source: { type: String, enum: ['linkedin', 'json', 'pdf', null] },
    importedAt: Date
  }

}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// √çndices
cvSchema.index({ user: 1, createdAt: -1 });
cvSchema.index({ 'sharing.publicUrl': 1 });
cvSchema.index({ slug: 1 });
cvSchema.index({ status: 1 });

// Virtual: nombre completo
cvSchema.virtual('personalInfo.fullName').get(function() {
  const first = this.personalInfo?.firstName || '';
  const last = this.personalInfo?.lastName || '';
  return `${first} ${last}`.trim();
});

// Virtual: URL p√∫blica completa
cvSchema.virtual('publicFullUrl').get(function() {
  if (this.sharing?.publicUrl) {
    return `${process.env.FRONTEND_URL}/cv/${this.sharing.publicUrl}`;
  }
  return null;
});

// Middleware: Generar slug √∫nico antes de guardar
cvSchema.pre('save', async function(next) {
  if (this.isNew || this.isModified('title')) {
    const baseSlug = this.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/(^-|-$)/g, '');
    
    let slug = baseSlug;
    let counter = 1;
    
    while (await mongoose.model('CV').findOne({ slug, _id: { $ne: this._id } })) {
      slug = `${baseSlug}-${counter}`;
      counter++;
    }
    
    this.slug = slug;
  }
  
  // Generar URL p√∫blica si es p√∫blico y no tiene
  if (this.sharing?.isPublic && !this.sharing.publicUrl) {
    this.sharing.publicUrl = uuidv4().substring(0, 8);
  }
  
  // Incrementar versi√≥n si hay cambios significativos
  if (!this.isNew && this.isModified()) {
    this.version += 1;
  }
  
  next();
});

// M√©todo: Clonar CV
cvSchema.methods.clone = async function(newUserId) {
  const clonedData = this.toObject();
  
  delete clonedData._id;
  delete clonedData.id;
  delete clonedData.slug;
  delete clonedData.createdAt;
  delete clonedData.updatedAt;
  delete clonedData.sharing;
  delete clonedData.analytics;
  
  clonedData.user = newUserId || this.user;
  clonedData.title = `${this.title} (copia)`;
  clonedData.status = 'draft';
  clonedData.version = 1;
  
  return mongoose.model('CV').create(clonedData);
};

// M√©todo: Incrementar vistas
cvSchema.methods.incrementViews = async function() {
  this.analytics.views += 1;
  this.analytics.lastViewed = new Date();
  return this.save();
};

// M√©todo: Incrementar descargas
cvSchema.methods.incrementDownloads = async function() {
  this.analytics.downloads += 1;
  this.analytics.lastDownloaded = new Date();
  return this.save();
};

// M√©todo: Exportar a JSON limpio
cvSchema.methods.toExportJSON = function() {
  const obj = this.toObject();
  
  // Eliminar campos internos
  delete obj._id;
  delete obj.id;
  delete obj.user;
  delete obj.__v;
  delete obj.createdAt;
  delete obj.updatedAt;
  delete obj.sharing;
  delete obj.analytics;
  delete obj.slug;
  
  return obj;
};

// Statics: Buscar CVs p√∫blicos
cvSchema.statics.findPublic = function(publicUrl) {
  return this.findOne({
    'sharing.publicUrl': publicUrl,
    'sharing.isPublic': true,
    $or: [
      { 'sharing.expiresAt': null },
      { 'sharing.expiresAt': { $gt: new Date() } }
    ]
  });
};

module.exports = mongoose.model('CV', cvSchema);
src/models/Analytics.js
javascript
const mongoose = require('mongoose');

const analyticsSchema = new mongoose.Schema({
  cv: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'CV',
    required: true,
    index: true
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  
  event: {
    type: String,
    enum: ['view', 'download', 'share', 'edit', 'create', 'delete', 'clone'],
    required: true
  },
  
  // Informaci√≥n del visitante
  visitor: {
    ip: String,
    userAgent: String,
    referer: String,
    country: String,
    city: String,
    device: {
      type: String,
      enum: ['desktop', 'mobile', 'tablet', 'unknown'],
      default: 'unknown'
    },
    browser: String,
    os: String
  },
  
  // Metadatos adicionales
  metadata: {
    format: String, // pdf, docx, etc.
    template: String,
    duration: Number, // Tiempo en la p√°gina (segundos)
    source: String // direct, linkedin, google, etc.
  },
  
  // Para agregaciones
  date: {
    type: Date,
    default: Date.now,
    index: true
  },
  hour: Number,
  dayOfWeek: Number,
  month: Number,
  year: Number

}, {
  timestamps: true
});

// √çndices compuestos para queries comunes
analyticsSchema.index({ cv: 1, event: 1, date: -1 });
analyticsSchema.index({ user: 1, date: -1 });
analyticsSchema.index({ date: -1, event: 1 });

// Middleware: Agregar campos de fecha
analyticsSchema.pre('save', function(next) {
  const now = this.date || new Date();
  this.hour = now.getHours();
  this.dayOfWeek = now.getDay();
  this.month = now.getMonth() + 1;
  this.year = now.getFullYear();
  next();
});

// Statics: Obtener estad√≠sticas de un CV
analyticsSchema.statics.getCVStats = async function(cvId, days = 30) {
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);
  
  const stats = await this.aggregate([
    {
      $match: {
        cv: new mongoose.Types.ObjectId(cvId),
        date: { $gte: startDate }
      }
    },
    {
      $group: {
        _id: '$event',
        count: { $sum: 1 }
      }
    }
  ]);
  
  const result = {
    views: 0,
    downloads: 0,
    shares: 0
  };
  
  stats.forEach(stat => {
    result[stat._id + 's'] = stat.count;
  });
  
  return result;
};

// Statics: Obtener estad√≠sticas por d√≠a
analyticsSchema.statics.getDailyStats = async function(cvId, days = 30) {
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);
  
  return this.aggregate([
    {
      $match: {
        cv: new mongoose.Types.ObjectId(cvId),
        date: { $gte: startDate }
      }
    },
    {
      $group: {
        _id: {
          date: { $dateToString: { format: '%Y-%m-%d', date: '$date' } },
          event: '$event'
        },
        count: { $sum: 1 }
      }
    },
    {
      $group: {
        _id: '$_id.date',
        events: {
          $push: {
            event: '$_id.event',
            count: '$count'
          }
        }
      }
    },
    { $sort: { _id: 1 } }
  ]);
};

// Statics: Obtener estad√≠sticas de usuario
analyticsSchema.statics.getUserStats = async function(userId) {
  return this.aggregate([
    {
      $match: {
        user: new mongoose.Types.ObjectId(userId)
      }
    },
    {
      $group: {
        _id: '$event',
        count: { $sum: 1 },
        lastOccurrence: { $max: '$date' }
      }
    }
  ]);
};

// Statics: Obtener dispositivos m√°s usados
analyticsSchema.statics.getDeviceStats = async function(cvId) {
  return this.aggregate([
    {
      $match: {
        cv: new mongoose.Types.ObjectId(cvId),
        event: 'view'
      }
    },
    {
      $group: {
        _id: '$visitor.device',
        count: { $sum: 1 }
      }
    },
    { $sort: { count: -1 } }
  ]);
};

module.exports = mongoose.model('Analytics', analyticsSchema);
4Ô∏è‚É£ Middleware de Autenticaci√≥n
src/middleware/auth.js
javascript
const jwt = require('jsonwebtoken');
const User = require('../models/User');

// Middleware principal de autenticaci√≥n
exports.protect = async (req, res, next) => {
  try {
    let token;
    
    // Obtener token del header
    if (req.headers.authorization?.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    } 
    // O de las cookies
    else if (req.cookies?.token) {
      token = req.cookies.token;
    }
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'No autorizado. Por favor inicia sesi√≥n.'
      });
    }
    
    try {
      // Verificar token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Buscar usuario
      const user = await User.findById(decoded.id);
      
      if (!user) {
        return res.status(401).json({
          success: false,
          message: 'El usuario ya no existe.'
        });
      }
      
      // Verificar si la cuenta est√° bloqueada
      if (user.isLocked()) {
        return res.status(423).json({
          success: false,
          message: 'Cuenta bloqueada temporalmente.'
        });
      }
      
      // Adjuntar usuario al request
      req.user = user;
      next();
      
    } catch (jwtError) {
      if (jwtError.name === 'TokenExpiredError') {
        return res.status(401).json({
          success: false,
          message: 'Sesi√≥n expirada. Por favor inicia sesi√≥n nuevamente.',
          code: 'TOKEN_EXPIRED'
        });
      }
      
      return res.status(401).json({
        success: false,
        message: 'Token inv√°lido.'
      });
    }
    
  } catch (error) {
    console.error('Auth middleware error:', error);
    res.status(500).json({
      success: false,
      message: 'Error de autenticaci√≥n.'
    });
  }
};

// Middleware opcional - no falla si no hay token
exports.optionalAuth = async (req, res, next) => {
  try {
    let token;
    
    if (req.headers.authorization?.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    } else if (req.cookies?.token) {
      token = req.cookies.token;
    }
    
    if (token) {
      try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = await User.findById(decoded.id);
      } catch (e) {
        // Token inv√°lido, pero continuamos sin usuario
        req.user = null;
      }
    }
    
    next();
  } catch (error) {
    next();
  }
};

// Middleware para verificar planes
exports.requirePlan = (...allowedPlans) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'No autorizado.'
      });
    }
    
    if (!allowedPlans.includes(req.user.plan)) {
      return res.status(403).json({
        success: false,
        message: `Esta funci√≥n requiere plan ${allowedPlans.join(' o ')}.`,
        code: 'PLAN_REQUIRED',
        requiredPlan: allowedPlans
      });
    }
    
    next();
  };
};

// Middleware para verificar propiedad del recurso
exports.requireOwnership = (model, paramName = 'id') => {
  return async (req, res, next) => {
    try {
      const Model = require(`../models/${model}`);
      const resource = await Model.findById(req.params[paramName]);
      
      if (!resource) {
        return res.status(404).json({
          success: false,
          message: 'Recurso no encontrado.'
        });
      }
      
      // Verificar propiedad
      const resourceUserId = resource.user?.toString() || resource.userId?.toString();
      
      if (resourceUserId !== req.user._id.toString()) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permiso para acceder a este recurso.'
        });
      }
      
      // Adjuntar recurso al request
      req.resource = resource;
      next();
      
    } catch (error) {
      console.error('Ownership check error:', error);
      res.status(500).json({
        success: false,
        message: 'Error verificando permisos.'
      });
    }
  };
};

// Middleware para verificar l√≠mites de uso
exports.checkUsageLimit = (limitType) => {
  return async (req, res, next) => {
    try {
      const user = req.user;
      const limits = user.getPlanLimits();
      
      switch (limitType) {
        case 'cvs':
          if (user.usage.cvsCreated >= limits.cvs) {
            return res.status(403).json({
              success: false,
              message: `Has alcanzado el l√≠mite de ${limits.cvs} CVs para tu plan.`,
              code: 'CV_LIMIT_REACHED',
              limit: limits.cvs,
              current: user.usage.cvsCreated
            });
          }
          break;
          
        case 'exports':
          if (user.usage.cvsExported >= limits.exports) {
            return res.status(403).json({
              success: false,
              message: `Has alcanzado el l√≠mite de ${limits.exports} exportaciones para tu plan.`,
              code: 'EXPORT_LIMIT_REACHED',
              limit: limits.exports,
              current: user.usage.cvsExported
            });
          }
          break;
      }
      
      next();
    } catch (error) {
      next(error);
    }
  };
};
src/middleware/rateLimiter.js
javascript
const rateLimit = require('express-rate-limit');

// Rate limiter general
exports.generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // 100 requests por ventana
  message: {
    success: false,
    message: 'Demasiadas solicitudes. Por favor espera unos minutos.',
    retryAfter: 15
  },
  standardHeaders: true,
  legacyHeaders: false
});

// Rate limiter para auth (m√°s estricto)
exports.authLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hora
  max: 10, // 10 intentos por hora
  message: {
    success: false,
    message: 'Demasiados intentos de inicio de sesi√≥n. Intenta en 1 hora.',
    retryAfter: 60
  },
  skipSuccessfulRequests: true
});

// Rate limiter para creaci√≥n de recursos
exports.createLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hora
  max: 30, // 30 creaciones por hora
  message: {
    success: false,
    message: 'Has creado demasiados recursos. Espera un momento.',
    retryAfter: 60
  }
});

// Rate limiter para exportaciones
exports.exportLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hora
  max: 20, // 20 exportaciones por hora
  message: {
    success: false,
    message: 'Has realizado demasiadas exportaciones. Espera un momento.',
    retryAfter: 60
  }
});

// Rate limiter para API p√∫blica
exports.publicApiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minuto
  max: 30, // 30 requests por minuto
  message: {
    success: false,
    message: 'Rate limit excedido.',
    retryAfter: 1
  }
});
src/middleware/validation.js
javascript
const { body, param, query, validationResult } = require('express-validator');

// Helper para manejar errores de validaci√≥n
exports.handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Datos de entrada inv√°lidos',
      errors: errors.array().map(err => ({
        field: err.path,
        message: err.msg
      }))
    });
  }
  
  next();
};

// Validaciones para registro
exports.validateRegister = [
  body('email')
    .trim()
    .isEmail()
    .withMessage('Email inv√°lido')
    .normalizeEmail(),
  body('password')
    .isLength({ min: 6 })
    .withMessage('La contrase√±a debe tener al menos 6 caracteres')
    .matches(/\d/)
    .withMessage('La contrase√±a debe contener al menos un n√∫mero'),
  body('name')
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('El nombre debe tener entre 2 y 100 caracteres')
    .escape()
];

// Validaciones para login
exports.validateLogin = [
  body('email')
    .trim()
    .isEmail()
    .withMessage('Email inv√°lido')
    .normalizeEmail(),
  body('password')
    .notEmpty()
    .withMessage('La contrase√±a es requerida')
];

// Validaciones para crear/actualizar CV
exports.validateCV = [
  body('title')
    .optional()
    .trim()
    .isLength({ min: 1, max: 100 })
    .withMessage('El t√≠tulo debe tener entre 1 y 100 caracteres'),
  body('personalInfo.firstName')
    .optional()
    .trim()
    .isLength({ max: 50 })
    .withMessage('Nombre muy largo'),
  body('personalInfo.lastName')
    .optional()
    .trim()
    .isLength({ max: 50 })
    .withMessage('Apellido muy largo'),
  body('personalInfo.contact.email')
    .optional()
    .trim()
    .isEmail()
    .withMessage('Email de contacto inv√°lido'),
  body('design.primaryColor')
    .optional()
    .matches(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)
    .withMessage('Color primario inv√°lido'),
  body('design.template')
    .optional()
    .isIn(['modern', 'classic', 'creative', 'minimal', 'executive', 'tech'])
    .withMessage('Plantilla inv√°lida')
];

// Validaci√≥n de ObjectId
exports.validateObjectId = (paramName = 'id') => [
  param(paramName)
    .isMongoId()
    .withMessage('ID inv√°lido')
];

// Validaciones para compartir CV
exports.validateShare = [
  body('isPublic')
    .optional()
    .isBoolean()
    .withMessage('isPublic debe ser booleano'),
  body('password')
    .optional()
    .isLength({ min: 4 })
    .withMessage('La contrase√±a debe tener al menos 4 caracteres'),
  body('expiresAt')
    .optional()
    .isISO8601()
    .withMessage('Fecha de expiraci√≥n inv√°lida')
];
5Ô∏è‚É£ Controladores
src/controllers/authController.js
javascript
const User = require('../models/User');
const crypto = require('crypto');

// @desc    Registrar usuario
// @route   POST /api/auth/register
// @access  Public
exports.register = async (req, res) => {
  try {
    const { email, password, name } = req.body;
    
    // Verificar si el usuario ya existe
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Este email ya est√° registrado'
      });
    }
    
    // Crear usuario
    const user = await User.create({
      email,
      password,
      name,
      provider: 'local'
    });
    
    // Generar token
    const token = user.generateAuthToken();
    
    // TODO: Enviar email de verificaci√≥n
    
    res.status(201).json({
      success: true,
      message: 'Usuario registrado exitosamente',
      data: {
        user: {
          id: user._id,
          email: user.email,
          name: user.name,
          plan: user.plan
        },
        token
      }
    });
    
  } catch (error) {
    console.error('Register error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al registrar usuario'
    });
  }
};

// @desc    Login usuario
// @route   POST /api/auth/login
// @access  Public
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Buscar y validar usuario
    const user = await User.findByCredentials(email, password);
    
    // Actualizar √∫ltimo login
    user.lastLogin = new Date();
    await user.save();
    
    // Generar token
    const token = user.generateAuthToken();
    
    res.json({
      success: true,
      message: 'Login exitoso',
      data: {
        user: {
          id: user._id,
          email: user.email,
          name: user.name,
          avatar: user.avatar,
          plan: user.plan,
          settings: user.settings
        },
        token
      }
    });
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(401).json({
      success: false,
      message: error.message || 'Error al iniciar sesi√≥n'
    });
  }
};

// @desc    Obtener usuario actual
// @route   GET /api/auth/me
// @access  Private
exports.getMe = async (req, res) => {
  try {
    const user = await User.findById(req.user._id)
      .populate({
        path: 'cvs',
        select: 'title slug status createdAt updatedAt analytics.views',
        options: { sort: { updatedAt: -1 }, limit: 10 }
      });
    
    res.json({
      success: true,
      data: {
        user: {
          id: user._id,
          email: user.email,
          name: user.name,
          avatar: user.avatar,
          plan: user.plan,
          settings: user.settings,
          usage: user.usage,
          isVerified: user.isVerified,
          createdAt: user.createdAt
        },
        recentCVs: user.cvs
      }
    });
    
  } catch (error) {
    console.error('GetMe error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener datos del usuario'
    });
  }
};

// @desc    Actualizar perfil
// @route   PUT /api/auth/profile
// @access  Private
exports.updateProfile = async (req, res) => {
  try {
    const allowedUpdates = ['name', 'settings'];
    const updates = {};
    
    Object.keys(req.body).forEach(key => {
      if (allowedUpdates.includes(key)) {
        updates[key] = req.body[key];
      }
    });
    
    const user = await User.findByIdAndUpdate(
      req.user._id,
      updates,
      { new: true, runValidators: true }
    );
    
    res.json({
      success: true,
      message: 'Perfil actualizado',
      data: {
        user: {
          id: user._id,
          email: user.email,
          name: user.name,
          settings: user.settings
        }
      }
    });
    
  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar perfil'
    });
  }
};

// @desc    Cambiar contrase√±a
// @route   PUT /api/auth/password
// @access  Private
exports.changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;
    
    const user = await User.findById(req.user._id).select('+password');
    
    // Verificar contrase√±a actual
    const isMatch = await user.comparePassword(currentPassword);
    if (!isMatch) {
      return res.status(400).json({
        success: false,
        message: 'Contrase√±a actual incorrecta'
      });
    }
    
    // Actualizar contrase√±a
    user.password = newPassword;
    await user.save();
    
    // Generar nuevo token
    const token = user.generateAuthToken();
    
    res.json({
      success: true,
      message: 'Contrase√±a actualizada',
      data: { token }
    });
    
  } catch (error) {
    console.error('Change password error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al cambiar contrase√±a'
    });
  }
};

// @desc    Solicitar reset de contrase√±a
// @route   POST /api/auth/forgot-password
// @access  Public
exports.forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;
    
    const user = await User.findOne({ email });
    
    if (!user) {
      // No revelar si el email existe o no
      return res.json({
        success: true,
        message: 'Si el email existe, recibir√°s instrucciones para resetear tu contrase√±a'
      });
    }
    
    // Generar token de reset
    const resetToken = crypto.randomBytes(32).toString('hex');
    
    user.resetPasswordToken = crypto
      .createHash('sha256')
      .update(resetToken)
      .digest('hex');
    user.resetPasswordExpires = Date.now() + 30 * 60 * 1000; // 30 minutos
    
    await user.save();
    
    // TODO: Enviar email con el token
    // const resetUrl = `${process.env.FRONTEND_URL}/reset-password/${resetToken}`;
    
    res.json({
      success: true,
      message: 'Si el email existe, recibir√°s instrucciones para resetear tu contrase√±a'
    });
    
  } catch (error) {
    console.error('Forgot password error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al procesar solicitud'
    });
  }
};

// @desc    Reset de contrase√±a
// @route   POST /api/auth/reset-password/:token
// @access  Public
exports.resetPassword = async (req, res) => {
  try {
    const { token } = req.params;
    const { password } = req.body;
    
    // Hash del token recibido
    const hashedToken = crypto
      .createHash('sha256')
      .update(token)
      .digest('hex');
    
    // Buscar usuario con token v√°lido
    const user = await User.findOne({
      resetPasswordToken: hashedToken,
      resetPasswordExpires: { $gt: Date.now() }
    });
    
    if (!user) {
      return res.status(400).json({
        success: false,
        message: 'Token inv√°lido o expirado'
      });
    }
    
    // Actualizar contrase√±a
    user.password = password;
    user.resetPasswordToken = undefined;
    user.resetPasswordExpires = undefined;
    user.loginAttempts = 0;
    user.lockUntil = undefined;
    
    await user.save();
    
    res.json({
      success: true,
      message: 'Contrase√±a actualizada exitosamente'
    });
    
  } catch (error) {
    console.error('Reset password error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al resetear contrase√±a'
    });
  }
};

// @desc    Logout (para cookies)
// @route   POST /api/auth/logout
// @access  Private
exports.logout = async (req, res) => {
  res.cookie('token', 'none', {
    expires: new Date(Date.now() + 10 * 1000),
    httpOnly: true
  });
  
  res.json({
    success: true,
    message: 'Sesi√≥n cerrada'
  });
};
src/controllers/cvController.js
javascript
const CV = require('../models/CV');
const Analytics = require('../models/Analytics');
const User = require('../models/User');

// @desc    Obtener todos los CVs del usuario
// @route   GET /api/cvs
// @access  Private
exports.getCVs = async (req, res) => {
  try {
    const { status, sort = '-updatedAt', page = 1, limit = 10 } = req.query;
    
    const query = { user: req.user._id };
    
    if (status) {
      query.status = status;
    }
    
    const cvs = await CV.find(query)
      .select('title slug status design.template personalInfo.firstName personalInfo.lastName analytics createdAt updatedAt')
      .sort(sort)
      .skip((page - 1) * limit)
      .limit(parseInt(limit));
    
    const total = await CV.countDocuments(query);
    
    res.json({
      success: true,
      data: {
        cvs,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / limit)
        }
      }
    });
    
  } catch (error) {
    console.error('Get CVs error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener CVs'
    });
  }
};

// @desc    Obtener un CV por ID
// @route   GET /api/cvs/:id
// @access  Private
exports.getCV = async (req, res) => {
  try {
    const cv = await CV.findOne({
      _id: req.params.id,
      user: req.user._id
    });
    
    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }
    
    res.json({
      success: true,
      data: { cv }
    });
    
  } catch (error) {
    console.error('Get CV error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener CV'
    });
  }
};

// @desc    Crear nuevo CV
// @route   POST /api/cvs
// @access  Private
exports.createCV = async (req, res) => {
  try {
    // Verificar l√≠mite de CVs
    if (!req.user.canCreateCV()) {
      return res.status(403).json({
        success: false,
        message: 'Has alcanzado el l√≠mite de CVs para tu plan',
        code: 'CV_LIMIT_REACHED'
      });
    }
    
    const cvData = {
      ...req.body,
      user: req.user._id
    };
    
    const cv = await CV.create(cvData);
    
    // Actualizar contador de usuario
    await User.findByIdAndUpdate(req.user._id, {
      $inc: { 'usage.cvsCreated': 1 }
    });
    
    // Registrar evento
    await Analytics.create({
      cv: cv._id,
      user: req.user._id,
      event: 'create'
    });
    
    res.status(201).json({
      success: true,
      message: 'CV creado exitosamente',
      data: { cv }
    });
    
  } catch (error) {
    console.error('Create CV error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al crear CV'
    });
  }
};

// @desc    Actualizar CV
// @route   PUT /api/cvs/:id
// @access  Private
exports.updateCV = async (req, res) => {
  try {
    const cv = await CV.findOneAndUpdate(
      { _id: req.params.id, user: req.user._id },
      { ...req.body, lastModifiedBy: req.user._id },
      { new: true, runValidators: true }
    );
    
    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }
    
    // Registrar evento
    await Analytics.create({
      cv: cv._id,
      user: req.user._id,
      event: 'edit'
    });
    
    res.json({
      success: true,
      message: 'CV actualizado',
      data: { cv }
    });
    
  } catch (error) {
    console.error('Update CV error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar CV'
    });
  }
};

// @desc    Eliminar CV
// @route   DELETE /api/cvs/:id
// @access  Private
exports.deleteCV = async (req, res) => {
  try {
    const cv = await CV.findOneAndDelete({
      _id: req.params.id,
      user: req.user._id
    });
    
    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }
    
    // Actualizar contador de usuario
    await User.findByIdAndUpdate(req.user._id, {
      $inc: { 'usage.cvsCreated': -1 }
    });
    
    // Eliminar analytics relacionados
    await Analytics.deleteMany({ cv: cv._id });
    
    res.json({
      success: true,
      message: 'CV eliminado'
    });
    
  } catch (error) {
    console.error('Delete CV error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar CV'
    });
  }
};

// @desc    Clonar CV
// @route   POST /api/cvs/:id/clone
// @access  Private
exports.cloneCV = async (req, res) => {
  try {
    // Verificar l√≠mite de CVs
    if (!req.user.canCreateCV()) {
      return res.status(403).json({
        success: false,
        message: 'Has alcanzado el l√≠mite de CVs para tu plan',
        code: 'CV_LIMIT_REACHED'
      });
    }
    
    const originalCV = await CV.findOne({
      _id: req.params.id,
      user: req.user._id
    });
    
    if (!originalCV) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }
    
    const clonedCV = await originalCV.clone();
    
    // Actualizar contador
    await User.findByIdAndUpdate(req.user._id, {
      $inc: { 'usage.cvsCreated': 1 }
    });
    
    // Registrar evento
    await Analytics.create({
      cv: clonedCV._id,
      user: req.user._id,
      event: 'clone',
      metadata: { originalCVId: originalCV._id }
    });
    
    res.status(201).json({
      success: true,
      message: 'CV clonado exitosamente',
      data: { cv: clonedCV }
    });
    
  } catch (error) {
    console.error('Clone CV error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al clonar CV'
    });
  }
};

// @desc    Exportar CV a JSON
// @route   GET /api/cvs/:id/export
// @access  Private
exports.exportCV = async (req, res) => {
  try {
    const cv = await CV.findOne({
      _id: req.params.id,
      user: req.user._id
    });
    
    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }
    
    const exportData = cv.toExportJSON();
    
    // Registrar evento
    await Analytics.create({
      cv: cv._id,
      user: req.user._id,
      event: 'download',
      metadata: { format: 'json' }
    });
    
    res.json({
      success: true,
      data: exportData
    });
    
  } catch (error) {
    console.error('Export CV error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al exportar CV'
    });
  }
};

// @desc    Importar CV desde JSON
// @route   POST /api/cvs/import
// @access  Private
exports.importCV = async (req, res) => {
  try {
    // Verificar l√≠mite
    if (!req.user.canCreateCV()) {
      return res.status(403).json({
        success: false,
        message: 'Has alcanzado el l√≠mite de CVs para tu plan',
        code: 'CV_LIMIT_REACHED'
      });
    }
    
    const importData = req.body;
    
    // Validar estructura b√°sica
    if (!importData.personalInfo && !importData.title) {
      return res.status(400).json({
        success: false,
        message: 'Formato de CV inv√°lido'
      });
    }
    
    const cv = await CV.create({
      ...importData,
      user: req.user._id,
      importedFrom: {
        source: 'json',
        importedAt: new Date()
      }
    });
    
    // Actualizar contador
    await User.findByIdAndUpdate(req.user._id, {
      $inc: { 'usage.cvsCreated': 1 }
    });
    
    res.status(201).json({
      success: true,
      message: 'CV importado exitosamente',
      data: { cv }
    });
    
  } catch (error) {
    console.error('Import CV error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al importar CV'
    });
  }
};
6Ô∏è‚É£ Configuraci√≥n de Passport (OAuth)
src/config/passport.js
javascript
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const LinkedInStrategy = require('passport-linkedin-oauth2').Strategy;
const User = require('../models/User');

// Serializaci√≥n
passport.serializeUser((user, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
  try {
    const user = await User.findById(id);
    done(null, user);
  } catch (error) {
    done(error, null);
  }
});

// Google Strategy
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: process.env.GOOGLE_CALLBACK_URL,
    scope: ['profile', 'email']
  },
  async (accessToken, refreshToken, profile, done) => {
    try {
      // Buscar usuario existente
      let user = await User
Claude Opus 4.5
continuar con la linea de codigo
// Buscar usuario existente
let user = await User


Continuemos exactamente desde donde quedamos:

src/config/passport.js (continuaci√≥n)
javascript
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const LinkedInStrategy = require('passport-linkedin-oauth2').Strategy;
const User = require('../models/User');

// Serializaci√≥n
passport.serializeUser((user, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
  try {
    const user = await User.findById(id);
    done(null, user);
  } catch (error) {
    done(error, null);
  }
});

// Google Strategy
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: process.env.GOOGLE_CALLBACK_URL,
    scope: ['profile', 'email']
  },
  async (accessToken, refreshToken, profile, done) => {
    try {
      // Buscar usuario existente
      let user = await User.findOne({
        $or: [
          { provider: 'google', providerId: profile.id },
          { email: profile.emails[0].value }
        ]
      });

      if (user) {
        // Si existe pero se registr√≥ con otro m√©todo, vincular cuenta
        if (user.provider !== 'google') {
          user.providerId = profile.id;
          user.avatar = user.avatar || profile.photos[0]?.value;
          await user.save();
        }
        
        // Actualizar √∫ltimo login
        user.lastLogin = new Date();
        await user.save();
        
        return done(null, user);
      }

      // Crear nuevo usuario
      user = await User.create({
        email: profile.emails[0].value,
        name: profile.displayName,
        avatar: profile.photos[0]?.value,
        provider: 'google',
        providerId: profile.id,
        isVerified: true, // Google ya verific√≥ el email
        lastLogin: new Date()
      });

      done(null, user);

    } catch (error) {
      console.error('Google OAuth error:', error);
      done(error, null);
    }
  }
));

// LinkedIn Strategy
passport.use(new LinkedInStrategy({
    clientID: process.env.LINKEDIN_CLIENT_ID,
    clientSecret: process.env.LINKEDIN_CLIENT_SECRET,
    callbackURL: process.env.LINKEDIN_CALLBACK_URL,
    scope: ['r_emailaddress', 'r_liteprofile'],
    state: true
  },
  async (accessToken, refreshToken, profile, done) => {
    try {
      // Buscar usuario existente
      let user = await User.findOne({
        $or: [
          { provider: 'linkedin', providerId: profile.id },
          { email: profile.emails[0].value }
        ]
      });

      if (user) {
        // Si existe pero se registr√≥ con otro m√©todo, vincular cuenta
        if (user.provider !== 'linkedin') {
          user.providerId = profile.id;
          user.avatar = user.avatar || profile.photos[0]?.value;
          await user.save();
        }
        
        user.lastLogin = new Date();
        await user.save();
        
        // Guardar accessToken temporalmente para importar datos despu√©s
        user._linkedInAccessToken = accessToken;
        
        return done(null, user);
      }

      // Crear nuevo usuario
      user = await User.create({
        email: profile.emails[0].value,
        name: profile.displayName,
        avatar: profile.photos[0]?.value,
        provider: 'linkedin',
        providerId: profile.id,
        isVerified: true,
        lastLogin: new Date()
      });

      // Guardar accessToken para importar datos
      user._linkedInAccessToken = accessToken;

      done(null, user);

    } catch (error) {
      console.error('LinkedIn OAuth error:', error);
      done(error, null);
    }
  }
));

module.exports = passport;
7Ô∏è‚É£ Rutas de la API
src/routes/auth.js
javascript
const express = require('express');
const router = express.Router();
const passport = require('passport');
const authController = require('../controllers/authController');
const { protect } = require('../middleware/auth');
const { authLimiter } = require('../middleware/rateLimiter');
const { 
  validateRegister, 
  validateLogin, 
  handleValidationErrors 
} = require('../middleware/validation');

// Rutas p√∫blicas con rate limiting
router.post('/register', 
  authLimiter,
  validateRegister, 
  handleValidationErrors, 
  authController.register
);

router.post('/login', 
  authLimiter,
  validateLogin, 
  handleValidationErrors, 
  authController.login
);

router.post('/forgot-password', 
  authLimiter,
  authController.forgotPassword
);

router.post('/reset-password/:token', 
  authLimiter,
  authController.resetPassword
);

// Rutas protegidas
router.get('/me', protect, authController.getMe);
router.put('/profile', protect, authController.updateProfile);
router.put('/password', protect, authController.changePassword);
router.post('/logout', protect, authController.logout);

// OAuth - Google
router.get('/google', 
  passport.authenticate('google', { 
    scope: ['profile', 'email'] 
  })
);

router.get('/google/callback',
  passport.authenticate('google', { 
    session: false,
    failureRedirect: `${process.env.FRONTEND_URL}/login?error=google_auth_failed`
  }),
  (req, res) => {
    // Generar token JWT
    const token = req.user.generateAuthToken();
    
    // Redirigir al frontend con el token
    res.redirect(`${process.env.FRONTEND_URL}/auth/callback?token=${token}`);
  }
);

// OAuth - LinkedIn
router.get('/linkedin',
  passport.authenticate('linkedin')
);

router.get('/linkedin/callback',
  passport.authenticate('linkedin', {
    session: false,
    failureRedirect: `${process.env.FRONTEND_URL}/login?error=linkedin_auth_failed`
  }),
  (req, res) => {
    const token = req.user.generateAuthToken();
    
    // Si tiene accessToken de LinkedIn, incluirlo para importar datos
    const linkedInToken = req.user._linkedInAccessToken;
    const redirectUrl = linkedInToken 
      ? `${process.env.FRONTEND_URL}/auth/callback?token=${token}&linkedin_import=true`
      : `${process.env.FRONTEND_URL}/auth/callback?token=${token}`;
    
    res.redirect(redirectUrl);
  }
);

module.exports = router;
src/routes/cv.js
javascript
const express = require('express');
const router = express.Router();
const cvController = require('../controllers/cvController');
const shareController = require('../controllers/shareController');
const { protect, optionalAuth, checkUsageLimit } = require('../middleware/auth');
const { createLimiter, exportLimiter } = require('../middleware/rateLimiter');
const { 
  validateCV, 
  validateObjectId,
  validateShare,
  handleValidationErrors 
} = require('../middleware/validation');

// Todas las rutas requieren autenticaci√≥n
router.use(protect);

// CRUD de CVs
router.route('/')
  .get(cvController.getCVs)
  .post(
    createLimiter,
    checkUsageLimit('cvs'),
    validateCV,
    handleValidationErrors,
    cvController.createCV
  );

router.route('/:id')
  .get(
    validateObjectId('id'),
    handleValidationErrors,
    cvController.getCV
  )
  .put(
    validateObjectId('id'),
    validateCV,
    handleValidationErrors,
    cvController.updateCV
  )
  .delete(
    validateObjectId('id'),
    handleValidationErrors,
    cvController.deleteCV
  );

// Clonar CV
router.post('/:id/clone',
  validateObjectId('id'),
  handleValidationErrors,
  checkUsageLimit('cvs'),
  cvController.cloneCV
);

// Exportar CV
router.get('/:id/export',
  exportLimiter,
  validateObjectId('id'),
  handleValidationErrors,
  cvController.exportCV
);

// Importar CV
router.post('/import',
  createLimiter,
  checkUsageLimit('cvs'),
  cvController.importCV
);

// Compartir CV
router.route('/:id/share')
  .get(
    validateObjectId('id'),
    handleValidationErrors,
    shareController.getShareSettings
  )
  .put(
    validateObjectId('id'),
    validateShare,
    handleValidationErrors,
    shareController.updateShareSettings
  );

// Generar nueva URL p√∫blica
router.post('/:id/share/regenerate-url',
  validateObjectId('id'),
  handleValidationErrors,
  shareController.regeneratePublicUrl
);

module.exports = router;
src/routes/share.js
javascript
const express = require('express');
const router = express.Router();
const shareController = require('../controllers/shareController');
const { optionalAuth } = require('../middleware/auth');
const { publicApiLimiter } = require('../middleware/rateLimiter');

// Rutas p√∫blicas para ver CVs compartidos
router.get('/:publicUrl',
  publicApiLimiter,
  optionalAuth,
  shareController.getPublicCV
);

// Verificar contrase√±a de CV protegido
router.post('/:publicUrl/verify',
  publicApiLimiter,
  shareController.verifyPassword
);

// Descargar CV p√∫blico (si est√° permitido)
router.get('/:publicUrl/download',
  publicApiLimiter,
  shareController.downloadPublicCV
);

module.exports = router;
src/routes/analytics.js
javascript
const express = require('express');
const router = express.Router();
const analyticsController = require('../controllers/analyticsController');
const { protect, requirePlan } = require('../middleware/auth');
const { validateObjectId, handleValidationErrors } = require('../middleware/validation');

router.use(protect);

// Dashboard general del usuario
router.get('/dashboard', analyticsController.getDashboard);

// Estad√≠sticas de un CV espec√≠fico
router.get('/cv/:id',
  validateObjectId('id'),
  handleValidationErrors,
  analyticsController.getCVAnalytics
);

// Estad√≠sticas detalladas (solo planes Pro/Enterprise)
router.get('/cv/:id/detailed',
  validateObjectId('id'),
  handleValidationErrors,
  requirePlan('pro', 'enterprise'),
  analyticsController.getDetailedAnalytics
);

// Exportar analytics
router.get('/export',
  requirePlan('pro', 'enterprise'),
  analyticsController.exportAnalytics
);

module.exports = router;
8Ô∏è‚É£ Controladores Adicionales
src/controllers/shareController.js
javascript
const CV = require('../models/CV');
const Analytics = require('../models/Analytics');
const bcrypt = require('bcryptjs');
const { v4: uuidv4 } = require('uuid');

// @desc    Obtener configuraci√≥n de compartir
// @route   GET /api/cvs/:id/share
// @access  Private
exports.getShareSettings = async (req, res) => {
  try {
    const cv = await CV.findOne({
      _id: req.params.id,
      user: req.user._id
    }).select('sharing title');

    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }

    res.json({
      success: true,
      data: {
        title: cv.title,
        sharing: {
          isPublic: cv.sharing?.isPublic || false,
          publicUrl: cv.sharing?.publicUrl,
          fullUrl: cv.publicFullUrl,
          hasPassword: !!cv.sharing?.password,
          expiresAt: cv.sharing?.expiresAt,
          allowDownload: cv.sharing?.allowDownload ?? true
        }
      }
    });

  } catch (error) {
    console.error('Get share settings error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener configuraci√≥n'
    });
  }
};

// @desc    Actualizar configuraci√≥n de compartir
// @route   PUT /api/cvs/:id/share
// @access  Private
exports.updateShareSettings = async (req, res) => {
  try {
    const { isPublic, password, expiresAt, allowDownload } = req.body;

    const cv = await CV.findOne({
      _id: req.params.id,
      user: req.user._id
    });

    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }

    // Inicializar sharing si no existe
    if (!cv.sharing) {
      cv.sharing = {};
    }

    // Actualizar configuraci√≥n
    if (typeof isPublic === 'boolean') {
      cv.sharing.isPublic = isPublic;
      
      // Generar URL p√∫blica si se hace p√∫blico y no tiene
      if (isPublic && !cv.sharing.publicUrl) {
        cv.sharing.publicUrl = uuidv4().substring(0, 8);
      }
    }

    if (password !== undefined) {
      if (password) {
        // Hash de la contrase√±a
        const salt = await bcrypt.genSalt(10);
        cv.sharing.password = await bcrypt.hash(password, salt);
      } else {
        // Eliminar contrase√±a
        cv.sharing.password = undefined;
      }
    }

    if (expiresAt !== undefined) {
      cv.sharing.expiresAt = expiresAt ? new Date(expiresAt) : undefined;
    }

    if (typeof allowDownload === 'boolean') {
      cv.sharing.allowDownload = allowDownload;
    }

    await cv.save();

    // Registrar evento
    await Analytics.create({
      cv: cv._id,
      user: req.user._id,
      event: 'share',
      metadata: { isPublic: cv.sharing.isPublic }
    });

    res.json({
      success: true,
      message: 'Configuraci√≥n actualizada',
      data: {
        sharing: {
          isPublic: cv.sharing.isPublic,
          publicUrl: cv.sharing.publicUrl,
          fullUrl: cv.publicFullUrl,
          hasPassword: !!cv.sharing.password,
          expiresAt: cv.sharing.expiresAt,
          allowDownload: cv.sharing.allowDownload
        }
      }
    });

  } catch (error) {
    console.error('Update share settings error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar configuraci√≥n'
    });
  }
};

// @desc    Regenerar URL p√∫blica
// @route   POST /api/cvs/:id/share/regenerate-url
// @access  Private
exports.regeneratePublicUrl = async (req, res) => {
  try {
    const cv = await CV.findOne({
      _id: req.params.id,
      user: req.user._id
    });

    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }

    // Generar nueva URL
    cv.sharing = cv.sharing || {};
    cv.sharing.publicUrl = uuidv4().substring(0, 8);
    
    await cv.save();

    res.json({
      success: true,
      message: 'URL regenerada',
      data: {
        publicUrl: cv.sharing.publicUrl,
        fullUrl: cv.publicFullUrl
      }
    });

  } catch (error) {
    console.error('Regenerate URL error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al regenerar URL'
    });
  }
};

// @desc    Obtener CV p√∫blico
// @route   GET /api/share/:publicUrl
// @access  Public
exports.getPublicCV = async (req, res) => {
  try {
    const { publicUrl } = req.params;

    const cv = await CV.findPublic(publicUrl);

    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado o no disponible'
      });
    }

    // Verificar si requiere contrase√±a
    if (cv.sharing.password) {
      // Verificar si ya se autentic√≥ (token en header)
      const authToken = req.headers['x-cv-auth'];
      
      if (!authToken) {
        return res.status(401).json({
          success: false,
          message: 'Este CV requiere contrase√±a',
          code: 'PASSWORD_REQUIRED'
        });
      }

      // Verificar token (simple, podr√≠a mejorarse con JWT)
      const expectedToken = Buffer.from(`${publicUrl}:${cv.sharing.password}`).toString('base64');
      
      if (authToken !== expectedToken) {
        return res.status(401).json({
          success: false,
          message: 'Contrase√±a incorrecta',
          code: 'INVALID_PASSWORD'
        });
      }
    }

    // Incrementar vistas
    await cv.incrementViews();

    // Registrar analytics
    await Analytics.create({
      cv: cv._id,
      user: cv.user,
      event: 'view',
      visitor: {
        ip: req.ip,
        userAgent: req.get('user-agent'),
        referer: req.get('referer')
      }
    });

    // Preparar respuesta (sin datos sensibles)
    const publicData = {
      title: cv.title,
      personalInfo: cv.personalInfo,
      experience: cv.experience,
      education: cv.education,
      skills: cv.skills,
      projects: cv.projects,
      certifications: cv.certifications,
      languages: cv.languages,
      customSections: cv.customSections,
      design: cv.design,
      sectionOrder: cv.sectionOrder,
      visibleSections: cv.visibleSections,
      allowDownload: cv.sharing.allowDownload
    };

    res.json({
      success: true,
      data: { cv: publicData }
    });

  } catch (error) {
    console.error('Get public CV error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener CV'
    });
  }
};

// @desc    Verificar contrase√±a de CV
// @route   POST /api/share/:publicUrl/verify
// @access  Public
exports.verifyPassword = async (req, res) => {
  try {
    const { publicUrl } = req.params;
    const { password } = req.body;

    const cv = await CV.findOne({
      'sharing.publicUrl': publicUrl,
      'sharing.isPublic': true
    }).select('+sharing.password');

    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }

    if (!cv.sharing.password) {
      return res.json({
        success: true,
        message: 'Este CV no requiere contrase√±a',
        data: { token: null }
      });
    }

    // Verificar contrase√±a
    const isMatch = await bcrypt.compare(password, cv.sharing.password);

    if (!isMatch) {
      return res.status(401).json({
        success: false,
        message: 'Contrase√±a incorrecta'
      });
    }

    // Generar token de acceso
    const token = Buffer.from(`${publicUrl}:${cv.sharing.password}`).toString('base64');

    res.json({
      success: true,
      message: 'Contrase√±a correcta',
      data: { token }
    });

  } catch (error) {
    console.error('Verify password error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al verificar contrase√±a'
    });
  }
};

// @desc    Descargar CV p√∫blico
// @route   GET /api/share/:publicUrl/download
// @access  Public
exports.downloadPublicCV = async (req, res) => {
  try {
    const { publicUrl } = req.params;

    const cv = await CV.findPublic(publicUrl);

    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }

    // Verificar si permite descargas
    if (!cv.sharing.allowDownload) {
      return res.status(403).json({
        success: false,
        message: 'Este CV no permite descargas'
      });
    }

    // Verificar contrase√±a si es necesario
    if (cv.sharing.password) {
      const authToken = req.headers['x-cv-auth'];
      const expectedToken = Buffer.from(`${publicUrl}:${cv.sharing.password}`).toString('base64');
      
      if (authToken !== expectedToken) {
        return res.status(401).json({
          success: false,
          message: 'Autenticaci√≥n requerida'
        });
      }
    }

    // Incrementar descargas
    await cv.incrementDownloads();

    // Registrar analytics
    await Analytics.create({
      cv: cv._id,
      user: cv.user,
      event: 'download',
      visitor: {
        ip: req.ip,
        userAgent: req.get('user-agent')
      },
      metadata: { format: req.query.format || 'json' }
    });

    // Por ahora, retornar JSON (PDF se implementar√° con Puppeteer)
    const exportData = cv.toExportJSON();

    res.json({
      success: true,
      data: exportData
    });

  } catch (error) {
    console.error('Download public CV error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al descargar CV'
    });
  }
};
src/controllers/analyticsController.js
javascript
const Analytics = require('../models/Analytics');
const CV = require('../models/CV');
const mongoose = require('mongoose');

// @desc    Obtener dashboard de analytics
// @route   GET /api/analytics/dashboard
// @access  Private
exports.getDashboard = async (req, res) => {
  try {
    const userId = req.user._id;
    
    // Obtener CVs del usuario
    const cvs = await CV.find({ user: userId }).select('_id title analytics');
    const cvIds = cvs.map(cv => cv._id);

    // Estad√≠sticas generales
    const totalStats = await Analytics.aggregate([
      {
        $match: {
          cv: { $in: cvIds }
        }
      },
      {
        $group: {
          _id: '$event',
          count: { $sum: 1 }
        }
      }
    ]);

    // Convertir a objeto
    const stats = {
      totalViews: 0,
      totalDownloads: 0,
      totalShares: 0,
      totalCVs: cvs.length
    };

    totalStats.forEach(stat => {
      if (stat._id === 'view') stats.totalViews = stat.count;
      if (stat._id === 'download') stats.totalDownloads = stat.count;
      if (stat._id === 'share') stats.totalShares = stat.count;
    });

    // Estad√≠sticas de los √∫ltimos 30 d√≠as
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const recentActivity = await Analytics.aggregate([
      {
        $match: {
          cv: { $in: cvIds },
          date: { $gte: thirtyDaysAgo }
        }
      },
      {
        $group: {
          _id: {
            date: { $dateToString: { format: '%Y-%m-%d', date: '$date' } }
          },
          views: {
            $sum: { $cond: [{ $eq: ['$event', 'view'] }, 1, 0] }
          },
          downloads: {
            $sum: { $cond: [{ $eq: ['$event', 'download'] }, 1, 0] }
          }
        }
      },
      { $sort: { '_id.date': 1 } }
    ]);

    // Top CVs por vistas
    const topCVs = cvs
      .map(cv => ({
        id: cv._id,
        title: cv.title,
        views: cv.analytics?.views || 0,
        downloads: cv.analytics?.downloads || 0
      }))
      .sort((a, b) => b.views - a.views)
      .slice(0, 5);

    res.json({
      success: true,
      data: {
        stats,
        recentActivity: recentActivity.map(item => ({
          date: item._id.date,
          views: item.views,
          downloads: item.downloads
        })),
        topCVs
      }
    });

  } catch (error) {
    console.error('Get dashboard error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener dashboard'
    });
  }
};

// @desc    Obtener analytics de un CV
// @route   GET /api/analytics/cv/:id
// @access  Private
exports.getCVAnalytics = async (req, res) => {
  try {
    const cv = await CV.findOne({
      _id: req.params.id,
      user: req.user._id
    });

    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }

    // Estad√≠sticas b√°sicas
    const stats = await Analytics.getCVStats(cv._id, 30);

    // Actividad por d√≠a (√∫ltimos 30 d√≠as)
    const dailyStats = await Analytics.getDailyStats(cv._id, 30);

    res.json({
      success: true,
      data: {
        cv: {
          id: cv._id,
          title: cv.title
        },
        stats: {
          views: stats.views,
          downloads: stats.downloads,
          shares: stats.shares,
          lastViewed: cv.analytics?.lastViewed,
          lastDownloaded: cv.analytics?.lastDownloaded
        },
        dailyStats: dailyStats.map(day => ({
          date: day._id,
          ...day.events.reduce((acc, e) => {
            acc[e.event + 's'] = e.count;
            return acc;
          }, { views: 0, downloads: 0 })
        }))
      }
    });

  } catch (error) {
    console.error('Get CV analytics error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener analytics'
    });
  }
};

// @desc    Obtener analytics detallados (Pro)
// @route   GET /api/analytics/cv/:id/detailed
// @access  Private (Pro/Enterprise)
exports.getDetailedAnalytics = async (req, res) => {
  try {
    const cv = await CV.findOne({
      _id: req.params.id,
      user: req.user._id
    });

    if (!cv) {
      return res.status(404).json({
        success: false,
        message: 'CV no encontrado'
      });
    }

    // Dispositivos
    const devices = await Analytics.getDeviceStats(cv._id);

    // Fuentes de tr√°fico
    const sources = await Analytics.aggregate([
      {
        $match: {
          cv: new mongoose.Types.ObjectId(cv._id),
          event: 'view'
        }
      },
      {
        $group: {
          _id: '$visitor.referer',
          count: { $sum: 1 }
        }
      },
      { $sort: { count: -1 } },
      { $limit: 10 }
    ]);

    // Horas m√°s activas
    const hourlyActivity = await Analytics.aggregate([
      {
        $match: {
          cv: new mongoose.Types.ObjectId(cv._id),
          event: 'view'
        }
      },
      {
        $group: {
          _id: '$hour',
          count: { $sum: 1 }
        }
      },
      { $sort: { _id: 1 } }
    ]);

    // Pa√≠ses (si se captura)
    const countries = await Analytics.aggregate([
      {
        $match: {
          cv: new mongoose.Types.ObjectId(cv._id),
          event: 'view',
          'visitor.country': { $exists: true, $ne: null }
        }
      },
      {
        $group: {
          _id: '$visitor.country',
          count: { $sum: 1 }
        }
      },
      { $sort: { count: -1 } },
      { $limit: 10 }
    ]);

    res.json({
      success: true,
      data: {
        devices: devices.map(d => ({
          device: d._id || 'unknown',
          count: d.count
        })),
        sources: sources.map(s => ({
          source: s._id || 'direct',
          count: s.count
        })),
        hourlyActivity: hourlyActivity.map(h => ({
          hour: h._id,
          count: h.count
        })),
        countries: countries.map(c => ({
          country: c._id,
          count: c.count
        }))
      }
    });

  } catch (error) {
    console.error('Get detailed analytics error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener analytics detallados'
    });
  }
};

// @desc    Exportar analytics
// @route   GET /api/analytics/export
// @access  Private (Pro/Enterprise)
exports.exportAnalytics = async (req, res) => {
  try {
    const { startDate, endDate, format = 'json' } = req.query;

    const cvs = await CV.find({ user: req.user._id }).select('_id');
    const cvIds = cvs.map(cv => cv._id);

    const query = { cv: { $in: cvIds } };

    if (startDate) {
      query.date = { $gte: new Date(startDate) };
    }
    if (endDate) {
      query.date = { ...query.date, $lte: new Date(endDate) };
    }

    const analytics = await Analytics.find(query)
      .populate('cv', 'title')
      .sort({ date: -1 })
      .limit(1000);

    if (format === 'csv') {
      // Generar CSV
      const headers = ['Fecha', 'CV', 'Evento', 'Dispositivo', 'Pa√≠s'];
      const rows = analytics.map(a => [
        a.date.toISOString(),
        a.cv?.title || 'N/A',
        a.event,
        a.visitor?.device || 'unknown',
        a.visitor?.country || 'N/A'
      ]);

      const csv = [headers, ...rows].map(row => row.join(',')).join('\n');

      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', 'attachment; filename=analytics.csv');
      return res.send(csv);
    }

    res.json({
      success: true,
      data: {
        analytics: analytics.map(a => ({
          date: a.date,
          cvTitle: a.cv?.title,
          event: a.event,
          device: a.visitor?.device,
          country: a.visitor?.country
        }))
      }
    });

  } catch (error) {
    console.error('Export analytics error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al exportar analytics'
    });
  }
};
9Ô∏è‚É£ Aplicaci√≥n Principal
src/app.js
javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const passport = require('passport');

// Importar configuraciones
require('./config/passport');

// Importar rutas
const authRoutes = require('./routes/auth');
const cvRoutes = require('./routes/cv');
const shareRoutes = require('./routes/share');
const analyticsRoutes = require('./routes/analytics');

// Importar middleware
const { generalLimiter } = require('./middleware/rateLimiter');

const app = express();

// ============ MIDDLEWARE DE SEGURIDAD ============
app.use(helmet({
  crossOriginResourcePolicy: { policy: "cross-origin" }
}));

// ============ CORS ============
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-CV-Auth']
}));

// ============ PARSERS ============
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// ============ LOGGING ============
if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev'));
} else {
  app.use(morgan('combined'));
}

// ============ PASSPORT ============
app.use(passport.initialize());

// ============ RATE LIMITING ============
app.use('/api', generalLimiter);

// ============ HEALTH CHECK ============
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// ============ RUTAS API ============
app.use('/api/auth', authRoutes);
app.use('/api/cvs', cvRoutes);
app.use('/api/share', shareRoutes);
app.use('/api/analytics', analyticsRoutes);

// ============ RUTA 404 ============
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    message: `Ruta ${req.originalUrl} no encontrada`
  });
});

// ============ ERROR HANDLER GLOBAL ============
app.use((err, req, res, next) => {
  console.error('Error:', err);

  // Error de Mongoose - Validaci√≥n
  if (err.name === 'ValidationError') {
    const messages = Object.values(err.errors).map(e => e.message);
    return res.status(400).json({
      success: false,
      message: 'Error de validaci√≥n',
      errors: messages
    });
  }

  // Error de Mongoose - Duplicado
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue)[0];
    return res.status(400).json({
      success: false,
      message: `El ${field} ya existe`
    });
  }

  // Error de Mongoose - CastError
  if (err.name === 'CastError') {
    return res.status(400).json({
      success: false,
      message: 'ID inv√°lido'
    });
  }

  // Error JWT
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      message: 'Token inv√°lido'
    });
  }

  // Error por defecto
  res.status(err.statusCode || 500).json({
    success: false,
    message: err.message || 'Error interno del servidor',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

module.exports = app;
server.js
javascript
require('dotenv').config();
const app = require('./src/app');
const connectDB = require('./src/config/database');

const PORT = process.env.PORT || 5000;

// Conectar a la base de datos
connectDB();

// Iniciar servidor
const server = app.listen(PORT, () => {
  console.log(`
  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
  ‚ïë                                        ‚ïë
  ‚ïë   üöÄ CV Generator API                  ‚ïë
  ‚ïë                                        ‚ïë
  ‚ïë   Server running on port ${PORT}         ‚ïë
  ‚ïë   Environment: ${process.env.NODE_ENV || 'development'}       ‚ïë
  ‚ïë                                        ‚ïë
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `);
});

// Manejar errores no capturados
process.on('unhandledRejection', (err) => {
  console.error('‚ùå Unhandled Rejection:', err);
  server.close(() => process.exit(1));
});

process.on('uncaughtException', (err) => {
  console.error('‚ùå Uncaught Exception:', err);
  process.exit(1);
});
üîü Servicio de LinkedIn (Importar Datos)
src/services/linkedinService.js
javascript
const axios = require('axios');

class LinkedInService {
  constructor(accessToken) {
    this.accessToken = accessToken;
    this.baseUrl = 'https://api.linkedin.com/v2';
  }

  async getProfile() {
    try {
      // Obtener perfil b√°sico
      const profileResponse = await axios.get(`${this.baseUrl}/me`, {
        headers: {
          'Authorization': `Bearer ${this.accessToken}`,
          'cache-control': 'no-cache',
          'X-Restli-Protocol-Version': '2.0.0'
        },
        params: {
          projection: '(id,firstName,lastName,profilePicture(displayImage~:playableStreams))'
        }
      });

      // Obtener email
      const emailResponse = await axios.get(`${this.baseUrl}/emailAddress`, {
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        },
        params: {
          q: 'members',
          projection: '(elements*(handle~))'
        }
      });

      const profile = profileResponse.data;
      const emailData = emailResponse.data;

      // Parsear nombre
      const firstName = this.getLocalizedValue(profile.firstName);
      const lastName = this.getLocalizedValue(profile.lastName);

      // Obtener foto
      let photoUrl = null;
      if (profile.profilePicture?.['displayImage~']?.elements) {
        const images = profile.profilePicture['displayImage~'].elements;
        const largestImage = images[images.length - 1];
        photoUrl = largestImage?.identifiers?.[0]?.identifier;
      }

      // Obtener email
      const email = emailData.elements?.[0]?.['handle~']?.emailAddress;

      return {
        firstName,
        lastName,
        email,
        photo: photoUrl,
        linkedinId: profile.id
      };

    } catch (error) {
      console.error('LinkedIn profile fetch error:', error.response?.data || error);
      throw new Error('Error al obtener perfil de LinkedIn');
    }
  }

  getLocalizedValue(localizedField) {
    if (!localizedField) return '';
    
    const locale = Object.keys(localizedField.localized)[0];
    return localizedField.localized[locale] || '';
  }

  // Convertir datos de LinkedIn a formato de CV
  static formatForCV(linkedinData) {
    return {
      personalInfo: {
        firstName: linkedinData.firstName || '',
        lastName: linkedinData.lastName || '',
        photo: linkedinData.photo,
        contact: {
          email: linkedinData.email || '',
          linkedin: `https://www.linkedin.com/in/${linkedinData.linkedinId}`
        }
      },
      importedFrom: {
        source: 'linkedin',
        importedAt: new Date()
      }
    };
  }
}

module.exports = LinkedInService;
üì± Frontend: Hook de API
src/hooks/useAPI.js (React)
javascript
import { useState, useCallback } from 'react';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

export const useAPI = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const getToken = () => localStorage.getItem('token');

  const request = useCallback(async (endpoint, options = {}) => {
    setLoading(true);
    setError(null);

    try {
      const token = getToken();
      
      const config = {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...(token && { 'Authorization': `Bearer ${token}` }),
          ...options.headers
        }
      };

      if (options.body && typeof options.body === 'object') {
        config.body = JSON.stringify(options.body);
      }

      const response = await fetch(`${API_URL}${endpoint}`, config);
      const data = await response.json();

      if (!response.ok) {
        // Token expirado
        if (response.status === 401 && data.code === 'TOKEN_EXPIRED') {
          localStorage.removeItem('token');
          window.location.href = '/login?expired=true';
          throw new Error('Sesi√≥n expirada');
        }

        throw new Error(data.message || 'Error en la solicitud');
      }

      return data;

    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // M√©todos de conveniencia
  const get = useCallback((endpoint) => 
    request(endpoint, { method: 'GET' }), [request]);

  const post = useCallback((endpoint, body) => 
    request(endpoint, { method: 'POST', body }), [request]);

  const put = useCallback((endpoint, body) => 
    request(endpoint, { method: 'PUT', body }), [request]);

  const del = useCallback((endpoint) => 
    request(endpoint, { method: 'DELETE' }), [request]);

  return {
    loading,
    error,
    request,
    get,
    post,
    put,
    del
  };
};

// Hook espec√≠fico para CVs
export const useCVAPI = () => {
  const api = useAPI();

  return {
    ...api,
    getCVs: (params) => api.get(`/cvs?${new URLSearchParams(params)}`),
    getCV: (id) => api.get(`/cvs/${id}`),
    createCV: (data) => api.post('/cvs', data),
    updateCV: (id, data) => api.put(`/cvs/${id}`, data),
    deleteCV: (id) => api.del(`/cvs/${id}`),
    cloneCV: (id) => api.post(`/cvs/${id}/clone`),
    exportCV: (id) => api.get(`/cvs/${id}/export`),
    importCV: (data) => api.post('/cvs/import', data),
    
    // Compartir
    getShareSettings: (id) => api.get(`/cvs/${id}/share`),
    updateShareSettings: (id, data) => api.put(`/cvs/${id}/share`, data),
    regenerateUrl: (id) => api.post(`/cvs/${id}/share/regenerate-url`)
  };
};

// Hook para autenticaci√≥n
export const useAuthAPI = () => {
  const api = useAPI();

  return {
    ...api,
    login: (credentials) => api.post('/auth/login', credentials),
    register: (data) => api.post('/auth/register', data),
    getMe: () => api.get('/auth/me'),
    updateProfile: (data) => api.put('/auth/profile', data),
    changePassword: (data) => api.put('/auth/password', data),
    forgotPassword: (email) => api.post('/auth/forgot-password', { email }),
    resetPassword: (token, password) => api.post(`/auth/reset-password/${token}`, { password }),
    logout: () => api.post('/auth/logout')
  };
};